Index: merlin/MerlinHaplotype.cpp
===================================================================
--- merlin/MerlinHaplotype.cpp	(revision 11)
+++ merlin/MerlinHaplotype.cpp	(working copy)
@@ -28,7 +28,7 @@
 #include <ctype.h>
 
 // Maximum number of haplotype vectors to list
-#define MAXIMUM_HAPLOTYPES    50
+#define MAXIMUM_HAPLOTYPES    500
 
 // Constructor and destructor
 //
Index: merlin/MerlinFamily.h
===================================================================
--- merlin/MerlinFamily.h	(revision 13)
+++ merlin/MerlinFamily.h	(working copy)
@@ -34,6 +34,9 @@
 // The MerlinCore class manages basic likelihood calculations
 #include "MerlinCore.h"
 
+#include <vector>
+#include <string>
+
 class FamilyAnalysis : public MerlinCore
    {
    public:
@@ -113,6 +116,9 @@
       // Pointer to handler for NPL information
       KongAndCox * kac;
 
+      // haplotype output, a hack by gw
+      std::vector< std::vector<std::string> > hapOutput;
+
    protected:
       // This function actually carries out most analyses
       virtual void AnalyseLocation(int pos, Tree & inheritance);
Index: merlin/MerlinHaplotype.cpp
===================================================================
--- merlin/MerlinHaplotype.cpp	(revision 13)
+++ merlin/MerlinHaplotype.cpp	(working copy)
@@ -130,8 +130,9 @@
          LabelChromosomes(m, inheritanceVector[0], haploString[m]);
       }
 
-   OutputHaplotypes(haploString, recombinantString, "[Uninformative]");
-   OutputFounders(haploString, "[Uninformative]");
+   // OutputHaplotypes(haploString, recombinantString, "[Uninformative]");
+   // OutputFounders(haploString, "[Uninformative]");
+   OutputHaplotypesHacked(haploString, recombinantString, which.hapOutput);
 
    // Free temporary storage
    delete [] haploString;
@@ -238,9 +239,10 @@
          marker++;
          }
 
-      OutputHaplotypes(haploString, recombinantString,
-                       sample ? "[Sampled]" : "[Most Likely]");
-      OutputFounders(haploString, sample ? "[Sampled]" : "[Most Likely]");
+      // OutputHaplotypes(haploString, recombinantString,
+      //                  sample ? "[Sampled]" : "[Most Likely]");
+      // OutputFounders(haploString, sample ? "[Sampled]" : "[Most Likely]");
+      OutputHaplotypesHacked(haploString, recombinantString, which.hapOutput);
 
       delete [] haploString;
       if (!sample && !family->zeroRecombination) delete [] right;
@@ -255,7 +257,54 @@
       throw;
       }
    }
+void MerlinHaplotype::OutputHaplotypesHacked(StringArray * haplo, StringArray & recomb,
+                                             std::vector< std::vector<std::string> > & hout)
+{
+	// sample output below -- famid, pid, haplotypes w/ recombination symbol
+	// 1	1	2:	2:	2:	2:	2:	2:	2:	2:
+	// 1	1	2:	2:	2:	2:	2:	2:	2:	2:
+	// 1	2	2:	2:	2:	2:	2:	2:	2:	2:
+	// 1	2	2:	2:	2:	2:	2:	2:	2:	2:
+	// 1	3	1:	A1,2:	1:	1:	1:	1:	1:	1:
+	// 1	3	2:	A2,1:	2:	2:	2:	2:	2:	2:
+	// 1	4	2:	2:	2:	2:	2:	2:	2:	2:
+	// 1	4	2:	2:	2:	2:	2:	2:	2:	2:
+	hout.resize(0);
+	// Output two haplotypes for each individual
+	for (int i = 0; i < family->mantra.two_n; i++) {
+		Person & person = family->ped[family->family->path[i >> 1]];
+		if ((person.sex == SEX_MALE && PedigreeGlobals::chromosomeX) && (i & 1)) continue;
+		//
+		std::vector<std::string> buffer(0);
+		std::string swapper;
+		swapper.assign((const char *)person.famid);
+		buffer.push_back(swapper);
+		swapper.assign((const char *)person.pid);
+		buffer.push_back(swapper);
 
+		String prefix, suffix;
+
+		for (int m = 0; m < family->markerCount; m++) {
+			prefix.Clear();
+			suffix.Clear();
+
+			for (int j = 0; j < haplo[m][i].Length(); j++)
+				if (haplo[m][i][j] == ' ')
+					continue;
+				else if (isalpha(haplo[m][i][j]))
+					prefix += haplo[m][i][j];
+				else
+					suffix += haplo[m][i][j];
+
+			swapper.assign((const char *)(prefix + suffix));
+			swapper.push_back(recomb[m].IsEmpty() ? ':' : recomb[m][i >> 1]);
+			buffer.push_back(swapper);
+		}
+		hout.push_back(buffer);
+	}
+}
+
+
 void MerlinHaplotype::OutputHaplotypes(
      StringArray * haploString, StringArray & recombString,
      const char * header_format, ...)
Index: merlin/MerlinHaplotype.h
===================================================================
--- merlin/MerlinHaplotype.h	(revision 13)
+++ merlin/MerlinHaplotype.h	(working copy)
@@ -25,6 +25,8 @@
 #include "MerlinCore.h"
 
 #include <stdio.h>
+#include <vector>
+#include <string>
 
 // Haplotyping routines
 //
@@ -69,5 +71,9 @@
                             const char * header_format, ...);
       void HorizontalOutput(StringArray * haplo);
 
+      // output to std vector, hacked by gw
+      void OutputHaplotypesHacked(StringArray *haplo, StringArray & recomb,
+                                  std::vector< std::vector<std::string> > & hout);
+
       // Founder haplotypes output broker
       void OutputFounders(StringArray * haplo, const char * label, int weight = 1);
       Index: merlin/MerlinFamily.h
===================================================================
--- merlin/MerlinFamily.h	(revision 14)
+++ merlin/MerlinFamily.h	(working copy)
@@ -118,6 +118,9 @@
 
       // haplotype output, a hack by gw
       std::vector< std::vector<std::string> > hapOutput;
+      // wipe errors from ped, hacked by gw
+      void ErrorWipeHack(Tree & withMarker, Tree & without, int marker);
+      int errorCountHack;
 
    protected:
       // This function actually carries out most analyses
// Index: merlin/MerlinFamily.cpp
// ===================================================================
// --- merlin/MerlinFamily.cpp	(revision 13)
// +++ merlin/MerlinFamily.cpp	(working copy)
// @@ -429,5 +429,68 @@
//        }
//     }
 
// +void FamilyAnalysis::ErrorWipeHack
// +    (Tree & withMarker, Tree & without, int informativeMarker)
// +{
// +	errorCountHack = 0;
// +	int marker = markers[informativeMarkers[informativeMarker]];
// +	MarkerCluster * cluster = clusters.Enabled() ? clusters.markerToCluster[marker] : NULL;
// +
// +	if (cluster == NULL && informativeCount <= 1) return;
// +
// +	FuzzyInheritanceTree alternative;
// +
// +	double multipoint_likelihood = stats.GetMean(withMarker);
// +
// +	int markers = cluster == NULL ? 1 : cluster->markerIds.Length();
// +	for (int m = 0; m < markers; m++) {
// +		double singlepoint_likelihood;
// +		if (cluster != NULL) {
// +			marker = cluster->markerIds[m];
// +			mantra.SelectMarker(marker);
// +			alternative.FuzzyScoreVectors(mantra);
// +
// +			singlepoint_likelihood = stats.GetMean(alternative);
// +		}else
// +			singlepoint_likelihood = stats.GetMean(singlepoint[informativeMarker]);
// +
// +		for (int error = family->first; error <= family->last; error++)
// +			if (ped[error].markers[marker].isKnown()) {
// +				bool iswiped = false;
// +				Alleles saved_genotype = ped[error].markers[marker];
// +				ped[error].markers[marker][0] = ped[error].markers[marker][1] = 0;
// +
// +				mantra.SelectMarker(marker);
// +				alternative.FuzzyScoreVectors(mantra);
// +
// +				double alternative_likelihood = stats.GetMean(alternative);
// +
// +				if (alternative_likelihood != singlepoint_likelihood) {
// +					if (cluster != NULL)
// +						cluster->ScoreLikelihood(mantra, alternative);
// +
// +					double alternative_multipoint = alternative.MeanProduct(without);
// +
// +					double score =
// +					    (multipoint_likelihood / alternative_multipoint) /
// +					    (singlepoint_likelihood / alternative_likelihood);
// +
// +					if (cluster != NULL)
// +						score *= exp(singlepoint[informativeMarker].logOffset -
// +							alternative.logOffset);
// +
// +					// wipe error
// +					if (score < 0.025) iswiped = true;
// +				}
// +
// +				if (!iswiped) ped[error].markers[marker] = saved_genotype;
// +				else {
// +					ped[error].markers[marker][0] = ped[error].markers[marker][1] = 0;
// +					errorCountHack += 1;
// +				}
// +			}
// +	}
// +}
// +
//  void FamilyAnalysis::ShowLODs()
//     {
//     if (storeKinshipForVc)